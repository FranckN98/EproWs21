# EPRO OKR-Projekt WS21/22

## Table of Contents
- [Usage](#usage)
- [Structure](#structure)
- [Architecture](#architecture)
  - [DB-Access](#dbaccess)
  - [Presentation](#presentation)
  - [Business Logic](#business_logic)
  - [Testing](#testing)
- [Known Bugs](#known_bugs)

## Usage
To run this project you need to have an instance of PostgreSQL running, with the database initialized.
We recommend using the provided Dockerfile (`docker/postgres/Dockerfile`) to build a Docker Container which runs the Database.
Alternatively you can also use the `createOkrDb.sql` Database initialization script on a custom installation of Postgresql,
but you might need to change the `spring.datasource` properties defined in the application.properties or set the
Properties yourself by passing them as Parameters when running the application.

For convenience, we also included a Hoppscotch collection, so that you can get started making requests to the Application
quickly. The Hoppscotch collection is located at in the `documentation` directory and is called `hoppscotchCollection.json`.

When using Hoppscotch to make requests, it is assumed, that you have the necessary environment variables set
(see `documentation/hoppscotch.md`). The `bearer` environment variable will be set automatically when making a request
to the `/login` endpoint.

For logging in you need send a Json-Body containing the username and the password like:
```json
{
  "username": "vor.nach1",
  "password": "password1"
}
```
Initially there are three available users. The credentials for each of them follow the previous pattern, you just need
to increment the number.

Each user has different Privileges:
vor.nach1:
- basically an admin account which can do everything

vor.nach2:
- Is a BusinessUnit Admin
- Can add and change BusinessUnitObjectives in their own Business Unit

vor.nach3:
- Is a normal User, which can only view items

## Structure
The `docker/postgres` directory contains the `createOkrDb.sql` file which is the init file for the Database.
It creates all necessary Tables and Triggers and inserts some sample Data, so initial Testing can be started easily.
The `Dockerfile` in the `docker/postgres` is for creating a Docker Container, which runs the Postgres Database, so that
one does not have to install a Postgres Database on ones development machine.

The `Dockerfile` in the project Root is for creating a Docker Container, which runs the Spring Application in a Docker 
Container.

## Architecture
In this project we separated DB-Access, Business Logic and Controllers/Presentation.

### DB-Access
The DB-Access is done via Data Access Objects (DAOs), which are implemented as Interfaces extending Spring Data's
`JpaRepository` Interface. The implementation of these Interfaces is generated by Spring.
All DAOs can be found in the `de.thbingen.epr.repository` package.

The Models, which represent the DB-Entities can be found in the `de.thbingen.epro.model.entity` package.
When generating the implementation of the repositories Spring uses these Models as return type for the Repository
Methods.

We decided to use Postgresql as database, as it was the best known database in the team.

Furthermore, we decided to offload whatever work we can to the Database. Thus, the achievement of any Objectives
and Key Results is calculated by the Database. Also, the historization has been implemented as a trigger in the database.

### Presentation
The Presentation layer consists only of Spring *Controllers*.

Further, HATEOAS is used to provide the users with the logical next steps when interacting with the API.

### Business Logic
The Business Logic has been implemented in Services, which can be found in the `de.thbingen.epro.service` package.
These Services are the interface between the Presentation Layer and the DB-Access Layer.
To prevent exposing Database internals, which should not be visible to the end-users of this application, we decided
to use the *Data Transfer Object* (DTO) Pattern. The DTOs live in the `de.thbingen.epro.model.dto` package.
As most Entities in this project are rather small, we only created a single DTO for all Operations for these Entities.
Some Entities like for example the `BusinessUnitKeyResult` Entity are rather large and can contain different data on
getting, posting or putting, we decided to create dedicated Post and Put DTOs for these larger Entities.

For mapping between the Entity and the DTO, we decided to use [Mapstruct](https://mapstruct.org/).
The Interface Declarations for the Mapstruct mappers can be found in the `de.thbingen.epro.model.mapper` package.

To enrich the Response, the DTOs the Service returns with the appropriate relation Links, Spring 
`RepresentationModelAssembler` are used.

Internally these `RepresentationModelAssembler`s, which are located in the `de.thbingen.epro.model.assembler` package,
use the mapstruct mappers, to convert an entity to the corresponding DTO and enrich it with the appropriate links.
The Assemblers are employed whenever a Service returns a DTO.

### Testing
For Testing we used Unit Tests for Controllers and Services.

Our Integration Tests run using [Testcontainers](https://www.testcontainers.org/), meaning that to run the Integration
Tests a Docker Installation is required.

Some Integration Tests could not be run as Transactional because of the way Postgres' generated Columns work, which is
why those tests have been disabled. Running each of those tests in isolation should show that they successfully complete
though.

## Known Bugs
- When `POST`ing or `PUT`ting a Business Unit Key Result or a Company Key Result, which should have an achievement higher 
  than 0 it will have an achievement of 0 in the Response Body. It appears that this is because of how Spring Data/Hibernate
  work.